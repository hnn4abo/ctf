from Crypto.Util.number import long_to_bytes

# copied from the 'MathyOracle' challenge
def GCD(N,k):
    while min(N,k)>0:
        if k>N: N,k = k,N
        N%=k
    return max(N,k)

N = 68410735253478047532669195609897926895002715632943461448660159313126496660033080937734557748701577020593482441014012783126085444004682764336220752851098517881202476417639649807333810261708210761333918442034275018088771547499619393557995773550772279857842207065696251926349053195423917250334982174308578108707
E = 65537
C = 4776006201999857533937746330553026200220638488579394063956998522022062232921285860886801454955588545654394710104334517021340109545003304904641820637316671869512340501549190724859489875329025743780939742424765825407663239591228764211985406490810832049380427145964590612241379808722737688823830921988891019862

# D(C)
DC = 58324527381741086207181449678831242444903897671571344216578285287377618832939516678686212825798172668450906644065483369735063383237979049248667084304630968896854046853486000780081390375682767386163384705607552367796490630893227401487357088304270489873369870382871693215188248166759293149916320915248800905458

P8 = GCD(N, C)
# Found from P8
P = 17649002407863577841
assert P8 == P**8
assert DC % (P**8) == 0

# Q*R
QR = N // P8
assert N == P**8 * QR

X = (DC // P) % QR
M = P * X
print (long_to_bytes(M>>(512//8)))